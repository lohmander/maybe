{"version":3,"sources":["../src/utils.ts","../src/Maybe.ts","../src/AsyncMaybe.ts","../src/functional.ts"],"names":["res"],"mappings":"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","file":"index.cjs","sourcesContent":["export function isNothing<T>(value?: T | null): value is null | undefined {\n  return value == null;\n}\n\nexport function isJust<T>(value?: T | null): value is T {\n  return !isNothing(value);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { ReturnMaybeType } from \"./types\";\nimport { isJust, isNothing } from \"./utils\";\n\n/**\n * Maybe<T> - A container for optional values.\n *\n * Represents either:\n *  - Just<T>: a present value of type T\n *  - Nothing: absence of value (null or undefined)\n *\n * Inspired by functional programming but designed for JS/TS ergonomics.\n */\nexport class Maybe<T> {\n  private constructor(public readonly _value: T | null | undefined) {}\n\n  /**\n   * Create a Maybe from a nullable value.\n   *\n   * @param value - A value that may be null or undefined.\n   * @returns A Maybe wrapping the value. Null/undefined become Nothing.\n   */\n  static fromNullable<T>(value: T | null | undefined): Maybe<T> {\n    return new Maybe(value);\n  }\n\n  /**\n   * Transform the value if present, otherwise propagate Nothing.\n   *\n   * @param fn - A function mapping the contained value to a new value.\n   * @returns A new Maybe of the mapped value, or Nothing if empty.\n   */\n  map<U>(fn: (value: T) => U): Maybe<U> {\n    if (isNothing(this._value)) return new Maybe<U>(this._value);\n    return new Maybe(fn(this._value as T));\n  }\n\n  /**\n   * Transform the value with a function returning Maybe.\n   * If Nothing, propagates Nothing.\n   *\n   * @param fn - A function mapping the contained value to a Maybe.\n   * @returns The resulting Maybe from applying the function, or Nothing if empty.\n   */\n  flatMap<U>(fn: (value: T) => Maybe<U>): Maybe<U> {\n    if (isNothing(this._value)) return new Maybe<U>(this._value);\n    return fn(this._value as T);\n  }\n\n  /**\n   * Replace Nothing with a default value, still wrapped in Maybe.\n   * Keeps chaining possible.\n   *\n   * @param defaultValue - The value to use if this is Nothing.\n   * @returns A Maybe containing the original or default value.\n   */\n  withDefault<U>(defaultValue: U): Maybe<T | U> {\n    return isNothing(this._value) ? new Maybe(defaultValue) : this;\n  }\n\n  /**\n   * Replace Nothing with a default value and unwrap.\n   * Ends the pipeline.\n   *\n   * @param defaultValue - The value to return if this is Nothing.\n   * @returns The contained value if present, otherwise the default.\n   */\n  getOrElse<U>(defaultValue: U): T | U {\n    return isNothing(this._value) ? defaultValue : (this._value as T);\n  }\n\n  /**\n   * Run a side-effect if Just; return the same Maybe.\n   *\n   * @param fn - A function executed with the contained value if present.\n   * @returns This Maybe instance, unchanged.\n   */\n  effect(fn: (value: T) => void): Maybe<T> {\n    if (isJust(this._value)) fn(this._value as T);\n    return this;\n  }\n\n  /**\n   * Filter the value with a predicate or type guard.\n   *\n   * Works like Array.filter:\n   * - With a predicate, keeps the value only if it passes.\n   * - With a type guard, also narrows the type of the Maybe.\n   *\n   * @param predicate - A predicate or type guard function.\n   * @returns A Maybe of the same or narrowed type if the predicate passes, otherwise Nothing.\n   *\n   * @example\n   * Maybe.fromNullable(5).filter(x => x > 3); // Maybe<number>\n   *\n   * @example\n   * const m: Maybe<unknown> = Maybe.fromNullable(\"hi\");\n   * const r = m.filter((x): x is string => typeof x === \"string\");\n   * // r inferred as Maybe<string>\n   */\n  filter<U extends T>(predicate: (value: T) => value is U): Maybe<U>;\n  filter(predicate: (value: T) => boolean): Maybe<T>;\n  filter(predicate: ((value: T) => boolean) | ((value: T) => value is any)): Maybe<any> {\n    if (isNothing(this._value) || !predicate(this._value as T)) return new Maybe<any>(null);\n\n    return new Maybe<any>(this._value);\n  }\n\n  /**\n   * Extend an object with a new property if present.\n   *\n   * @param key - The property name to add.\n   * @param fn - A function returning a Maybe of the new property value.\n   * @returns A Maybe of the extended object, or Nothing if empty or not an object.\n   */\n  extend<K extends string, U>(key: K, fn: (value: T) => Maybe<U>): Maybe<T & { [P in K]: U }> {\n    if (isNothing(this._value) || typeof this._value !== \"object\")\n      return new Maybe<T & { [P in K]: U }>(null);\n\n    // Use a broadly-typed approach here to keep the API ergonomic.\n\n    return this.flatMap((obj: any) =>\n      fn(obj).map((u: any) => ({ ...(obj as any), [key]: u })),\n    ) as any;\n  }\n\n  /**\n   * Assign one or more properties to an object inside a Maybe.\n   * Runs all property functions and short-circuits to Nothing if:\n   * - the Maybe is Nothing\n   * - the value is not an object\n   * - any property function returns Nothing\n   *\n   * @param fns - An object where keys are property names and values are functions\n   *              returning a Maybe of the property value.\n   * @returns A Maybe of the extended object, or Nothing if short-circuited.\n   */\n  assign<Exts extends Record<string, (value: T) => Maybe<any>>>(\n    fns: Exts,\n  ): Maybe<\n    T & {\n      [K in keyof Exts]: ReturnMaybeType<Exts[K]>;\n    }\n  > {\n    if (isNothing(this._value) || typeof this._value !== \"object\") return new Maybe<any>(null);\n\n    const obj = this._value as T;\n\n    return Object.entries(fns).reduce(\n      (acc: any, [k, fn]: [string, (v: T) => Maybe<any>]) =>\n        acc.flatMap((lastVal: any) => fn(obj).map((v: any) => ({ ...lastVal, [k]: v }))),\n      new Maybe(obj),\n    ) as any;\n  }\n\n  /**\n   * Map and filter over an array inside a Maybe.\n   * If Nothing, returns Nothing. If Just with an array,\n   * applies the function to each element, keeping only Just results.\n   *\n   * @typeParam U - The element type of the original array.\n   * @typeParam V - The element type of the resulting array.\n   * @param fn - A function mapping each element to a Maybe.\n   * @returns A Maybe of the filtered/mapped array, or Nothing if empty.\n   */\n  filterMap<U, V>(this: Maybe<U[]>, fn: (value: U) => Maybe<V>): Maybe<V[]> {\n    if (isNothing(this._value)) return new Maybe<V[]>(null);\n\n    const arr = this._value as U[];\n    const result: V[] = [];\n\n    for (const el of arr) {\n      const maybeVal = fn(el);\n      if (!(maybeVal instanceof Maybe)) return Maybe.fromNullable<V[]>(null);\n\n      if (isJust(maybeVal.value())) result.push(maybeVal.value() as V);\n    }\n\n    return new Maybe(result);\n  }\n\n  /**\n   * Access the raw inner value.\n   *\n   * Escape hatch; prefer getOrElse() in most cases.\n   *\n   * @returns The contained value if present, otherwise null or undefined.\n   */\n  value(): T | null | undefined {\n    return this._value;\n  }\n}\n","import { Maybe } from \"./Maybe\";\nimport type { ReturnMaybeType } from \"./types\";\nimport { isJust, isNothing } from \"./utils\";\n\n/**\n * AsyncMaybe<T> - An async container for optional values.\n *\n * Represents a Promise that resolves to either:\n *  - Just<T>: a present value of type T\n *  - Nothing: absence of value (null or undefined)\n *\n * Mirrors Maybe’s API but for async flows, reusing Maybe internally\n * wherever possible.\n */\nexport class AsyncMaybe<T> {\n  private constructor(public readonly _value: Promise<T | null | undefined>) {}\n\n  /**\n   * fromNullable - Creates an AsyncMaybe from a possibly-null/undefined value.\n   *\n   * @typeParam T - The type of the contained value.\n   * @param value - A value that may be null or undefined.\n   * @returns An AsyncMaybe wrapping the given value.\n   */\n  static fromNullable<T>(value: T | null | undefined): AsyncMaybe<T> {\n    return new AsyncMaybe(Promise.resolve(value));\n  }\n\n  /**\n   * fromPromise - Creates an AsyncMaybe from a Promise.\n   *\n   * @typeParam T - The type of the resolved value.\n   * @param promise - A promise resolving to a value that may be null/undefined.\n   * @returns An AsyncMaybe wrapping the promise.\n   */\n  static fromPromise<T>(promise: Promise<T | null | undefined>): AsyncMaybe<T> {\n    return new AsyncMaybe(promise);\n  }\n\n  /**\n   * fromMaybe - Lifts a synchronous Maybe into an AsyncMaybe.\n   *\n   * @typeParam T - The type contained by the Maybe.\n   * @param maybe - A Maybe instance.\n   * @returns An AsyncMaybe wrapping the Maybe’s value.\n   */\n  static fromMaybe<T>(maybe: Maybe<T>): AsyncMaybe<T> {\n    return new AsyncMaybe(Promise.resolve(maybe.value()));\n  }\n\n  /**\n   * map - Transforms the inner value if present.\n   *\n   * @typeParam U - The result type of the mapping function.\n   * @param fn - A function mapping the contained value.\n   * @returns A new AsyncMaybe with the mapped value, or Nothing if absent.\n   */\n  map<U>(fn: (value: T) => U): AsyncMaybe<U> {\n    const next = (async () => {\n      const v = await this._value;\n      return Maybe.fromNullable(v).map(fn).value();\n    })();\n    return new AsyncMaybe(next);\n  }\n\n  /**\n   * flatMap - Chains async or sync Maybe-like computations.\n   *\n   * Accepts functions returning:\n   *  - Maybe<U>\n   *  - AsyncMaybe<U>\n   *  - U\n   *  - Promise<Maybe<U> | AsyncMaybe<U> | U>\n   *\n   * @typeParam U - The type returned by the function.\n   * @param fn - A function that transforms the contained value.\n   * @returns A new AsyncMaybe containing the flattened result, or Nothing if absent.\n   */\n  flatMap<U>(\n    fn: (value: T) => Maybe<U> | AsyncMaybe<U> | U | Promise<Maybe<U> | AsyncMaybe<U> | U>,\n  ): AsyncMaybe<U> {\n    const next = (async () => {\n      const v = await this._value;\n      if (isNothing(v)) return v as unknown as U;\n\n      const out = await fn(v as T);\n      if (out instanceof AsyncMaybe) return await out.value();\n      if (out instanceof Maybe) return out.value();\n      return out as U;\n    })();\n    return new AsyncMaybe(next);\n  }\n\n  /**\n   * filter - Narrows or discards the value based on a predicate or type guard.\n   *\n   * Semantics:\n   *  - If the source is Nothing (null/undefined), it is preserved as-is.\n   *  - If the source is present but the predicate fails, the result is **undefined**.\n   *  - With a type guard, the resulting AsyncMaybe’s type is narrowed.\n   *\n   * @typeParam U - The narrowed type (when using a type guard).\n   * @param predicate - A boolean predicate or type guard.\n   * @returns A new AsyncMaybe with the original value if it passes, or Nothing.\n   */\n  filter<U extends T>(predicate: (value: T) => value is U): AsyncMaybe<U>;\n  filter(predicate: (value: T) => boolean): AsyncMaybe<T>;\n  // Relax predicate type so user-supplied type predicates work when T is arbitrary.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  filter(predicate: ((value: T) => boolean) | ((value: T) => value is any)): AsyncMaybe<any> {\n    const next = (async () => {\n      const v = await this._value;\n      if (v == null) {\n        // preserve null/undefined\n        return v;\n      }\n      // Only keep if predicate passes\n      if ((predicate as (v: T) => boolean)(v as T)) return v;\n\n      // present but failed → null\n      return null;\n    })();\n    return new AsyncMaybe(next);\n  }\n\n  /**\n   * extend - Extends an object with a new property if present.\n   *\n   * Uses `filter`’s semantics, so:\n   *  - null/undefined are preserved,\n   *  - non-object present values become undefined.\n   *\n   * @typeParam K - The property key to add.\n   * @typeParam U - The property value type.\n   * @param key - The property name.\n   * @param fn - A function returning a Maybe/AsyncMaybe/value for the property.\n   * @returns A new AsyncMaybe containing the extended object, or Nothing.\n   */\n  extend<K extends string, U>(\n    key: K,\n    fn: (value: T) => Maybe<U> | AsyncMaybe<U> | U | Promise<Maybe<U> | AsyncMaybe<U> | U>,\n  ): AsyncMaybe<T & { [P in K]: U }> {\n    return this.filter((v): v is T & object => typeof v === \"object\" && v !== null).flatMap((obj) =>\n      AsyncMaybe.fromPromise(\n        (async () => {\n          const out = await fn(obj);\n          const lifted =\n            out instanceof AsyncMaybe\n              ? out\n              : out instanceof Maybe\n                ? AsyncMaybe.fromMaybe(out)\n                : AsyncMaybe.fromNullable(out as U);\n\n          const newVal = await lifted.value();\n          return newVal == null\n            ? null\n            : ({ ...(obj as T & Record<string, unknown>), [key]: newVal } as T & { [P in K]: U });\n        })(),\n      ),\n    );\n  }\n\n  /**\n   * Assign one or more properties to an object inside an AsyncMaybe.\n   * Runs all property functions in parallel and short-circuits to Nothing if:\n   * - the AsyncMaybe is Nothing\n   * - the value is not an object\n   * - any property function returns Nothing\n   *\n   * @param fns - An object where keys are property names and values are functions\n   *              returning a Maybe or AsyncMaybe of the property value.\n   * @returns An AsyncMaybe of the extended object, or Nothing if short-circuited.\n   */\n  assign<\n    Exts extends Record<\n      string,\n      // allow functions with a loose parameter type to avoid incompatibility when T is generic\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (value: any) => Maybe<any> | AsyncMaybe<any> | Promise<Maybe<any> | AsyncMaybe<any>>\n    >,\n  >(\n    fns: Exts,\n  ): AsyncMaybe<\n    T & {\n      [P in keyof Exts]: ReturnMaybeType<Exts[P]>;\n    }\n  > {\n    return this.flatMap((obj) => {\n      if (typeof obj !== \"object\" || obj === null) return AsyncMaybe.fromNullable(null);\n\n      // Run all extenders in parallel\n      const tasks = Object.entries(fns).map(async ([key, fn]) => {\n        const res = await Promise.resolve(fn(obj)).then((res) => res.value());\n        return [key, res] as const;\n      });\n\n      return AsyncMaybe.fromPromise(\n        Promise.all(tasks).then((resolved) => {\n          // Short-circuit: if any extender is Nothing, bail out\n          if (resolved.some(([, v]) => isNothing(v))) return null;\n\n          return { ...obj, ...Object.fromEntries(resolved) };\n        }),\n      );\n    }) as AsyncMaybe<T & { [P in keyof Exts]: ReturnMaybeType<Exts[P]> }>;\n  }\n\n  /**\n   * filterMap - Maps and filters an array inside an AsyncMaybe.\n   *\n   * Semantics:\n   *  - If the source is null/undefined, it is preserved as-is.\n   *  - If the source is present but **not an array**, the result is **undefined**.\n   *  - Array elements mapped to null/undefined are dropped.\n   *\n   * @typeParam U - The element type of the source array.\n   * @typeParam V - The element type of the result array.\n   * @param fn - A function returning a Maybe/AsyncMaybe/value for each element.\n   * @returns A new AsyncMaybe containing the filtered/mapped array, or Nothing.\n   */\n  filterMap<U, V>(\n    this: AsyncMaybe<U[]>,\n    fn: (value: U) => Maybe<V> | AsyncMaybe<V> | V | Promise<Maybe<V> | AsyncMaybe<V> | V>,\n  ): AsyncMaybe<V[]> {\n    const next = (async () => {\n      const raw = await this._value;\n\n      // Preserve original Nothing exactly\n      if (raw == null) return raw as unknown as V[] | null | undefined;\n\n      // Present but not an array → undefined\n      if (!Array.isArray(raw)) return null;\n\n      const values = await Promise.all(\n        (raw as U[]).map(async (el) => {\n          const out = await fn(el);\n          if (out instanceof AsyncMaybe) return await out.value();\n          if (out instanceof Maybe) return out.value();\n          return out as V;\n        }),\n      );\n\n      return values.filter((v) => v != null) as V[];\n    })();\n\n    return new AsyncMaybe(next);\n  }\n\n  /**\n   * withDefault - Provides a default value if Nothing.\n   *\n   * @typeParam U - The type of the default value.\n   * @param defaultValue - A fallback value.\n   * @returns A new AsyncMaybe containing the original or default value.\n   */\n  withDefault<U>(defaultValue: U): AsyncMaybe<T | U> {\n    const next = (async () => {\n      const v = await this._value;\n      return Maybe.fromNullable(v).withDefault(defaultValue).value();\n    })();\n    return new AsyncMaybe<T | U>(next);\n  }\n\n  /**\n   * getOrElse - Provides a default value if Nothing and unwraps the result.\n   *\n   * @typeParam U - The type of the default value.\n   * @param defaultValue - A fallback value.\n   * @returns A Promise resolving to the original or default value.\n   */\n  async getOrElse<U>(defaultValue: U): Promise<T | U> {\n    const v = await this._value;\n    return Maybe.fromNullable(v).getOrElse(defaultValue);\n  }\n\n  /**\n   * effect - Executes a side-effect if Just.\n   *\n   * @param fn - A function to run with the contained value if present.\n   * @returns A new AsyncMaybe containing the original value.\n   */\n  effect(fn: (value: T) => void | Promise<void>): AsyncMaybe<T> {\n    const next = (async () => {\n      const v = await this._value;\n      const m = Maybe.fromNullable(v);\n      if (isJust(m.value())) await fn(m.value() as T);\n      return v;\n    })();\n    return new AsyncMaybe(next);\n  }\n\n  /**\n   * value - Accesses the raw underlying promise.\n   *\n   * Escape hatch; prefer getOrElse() in most cases.\n   *\n   * @returns A Promise resolving to the contained value or Nothing.\n   */\n  value(): Promise<T | null | undefined> {\n    return this._value;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { AsyncMaybe } from \"./AsyncMaybe\";\nimport { Maybe } from \"./Maybe\";\nimport type { ReturnMaybeType } from \"./types\";\n\n/**\n * Lightweight functional wrappers for Maybe and AsyncMaybe.\n *\n * This file intentionally uses `any` in the implementation bodies to keep\n * overloads simple and to avoid TypeScript inference edge cases in the\n * wrapper layer. The public typings on the overloads remain accurate.\n *\n * The implementation simply forwards to the appropriate method on the\n * provided container (Maybe or AsyncMaybe) using casts to `any`.\n */\n\n/* re-exports for convenience */\nexport const fromNullable = Maybe.fromNullable;\nexport const fromPromise = AsyncMaybe.fromPromise;\nexport const fromMaybe = AsyncMaybe.fromMaybe;\n\n/* map */\nexport function map<A, B>(\n  fn: (value: A) => B,\n): {\n  (m: AsyncMaybe<A>): AsyncMaybe<B>;\n  (m: Maybe<A>): Maybe<B>;\n} {\n  return ((m: any) => (m as any).map(fn as any)) as any;\n}\n\n/* flatMap */\nexport function flatMap<A, B>(\n  fn: (a: A) => Maybe<B>,\n): {\n  (m: Maybe<A>): Maybe<B>;\n  (m: AsyncMaybe<A>): AsyncMaybe<B>;\n};\nexport function flatMap<A, B>(\n  fn: (a: A) => AsyncMaybe<B>,\n): {\n  (m: Maybe<A> | AsyncMaybe<A>): AsyncMaybe<B>;\n};\nexport function flatMap<A, B>(\n  fn: (a: A) => Maybe<B> | AsyncMaybe<B>,\n): (m: any) => Maybe<B> | AsyncMaybe<B> {\n  return ((m: any) => (m as any).flatMap(fn as any)) as any;\n}\n\n/* filter */\nexport function filter<A, B extends A>(\n  predicate: (value: A) => value is B,\n): {\n  (m: Maybe<A>): Maybe<B>;\n  (m: AsyncMaybe<A>): AsyncMaybe<B>;\n};\nexport function filter<A>(predicate: (value: A) => boolean): {\n  (m: Maybe<A>): Maybe<A>;\n  (m: AsyncMaybe<A>): AsyncMaybe<A>;\n};\nexport function filter<A>(predicate: (value: A) => boolean): {\n  (m: Maybe<A>): Maybe<A>;\n  (m: AsyncMaybe<A>): AsyncMaybe<A>;\n} {\n  return ((m: any) => (m as any).filter(predicate as any)) as any;\n}\n\n/* filterMap */\nexport function filterMap<A, B>(\n  fn: (value: A) => Maybe<B>,\n): {\n  <M extends Maybe<A[]> | AsyncMaybe<A[]>>(\n    m: M,\n  ): M extends AsyncMaybe<A[]> ? AsyncMaybe<B[]> : Maybe<B[]>;\n};\nexport function filterMap<A, B>(\n  fn: (value: A) => AsyncMaybe<B>,\n): {\n  (m: Maybe<A[]>): AsyncMaybe<B[]>;\n  (m: AsyncMaybe<A[]>): AsyncMaybe<B[]>;\n};\nexport function filterMap<A, B>(\n  fn: (value: A) => Maybe<B> | AsyncMaybe<B>,\n): (m: any) => Maybe<B[]> | AsyncMaybe<B[]> {\n  return ((m: any) => (m as any).filterMap(fn as any)) as any;\n}\n\n/* extend */\nexport function extend<A extends object, K extends string, B>(\n  key: K,\n  fn: (value: A) => Maybe<B>,\n): {\n  (m: Maybe<A>): Maybe<A & { [P in K]: B }>;\n  (m: AsyncMaybe<A>): AsyncMaybe<A & { [P in K]: B }>;\n};\nexport function extend<A extends object, K extends string, B>(\n  key: K,\n  fn: (value: A) => AsyncMaybe<B>,\n): {\n  (m: Maybe<A> | AsyncMaybe<A>): AsyncMaybe<A & { [P in K]: B }>;\n};\nexport function extend<A extends object, K extends string, B>(\n  key: K,\n  fn: (value: A) => Maybe<B> | AsyncMaybe<B>,\n): {\n  (m: Maybe<A> | AsyncMaybe<A>): any;\n} {\n  return ((m: any) => (m as any).extend(key, fn as any)) as any;\n}\n\n/* assign */\nexport function assign<A extends object, Exts extends Record<string, (value: A) => Maybe<any>>>(\n  fns: Exts,\n): (m: Maybe<A>) => Maybe<\n  A & {\n    [P in keyof Exts]: ReturnMaybeType<Exts[P]>;\n  }\n>;\nexport function assign<\n  A extends object,\n  Exts extends Record<\n    string,\n    (value: A) => Maybe<any> | AsyncMaybe<any> | Promise<Maybe<any> | AsyncMaybe<any>>\n  >,\n>(\n  fns: Exts,\n): (m: Maybe<A> | AsyncMaybe<A>) => AsyncMaybe<\n  A & {\n    [P in keyof Exts]: ReturnMaybeType<Exts[P]>;\n  }\n>;\nexport function assign<\n  A extends object,\n  Exts extends Record<string, (value: A) => Maybe<any> | AsyncMaybe<any>>,\n>(fns: Exts): (m: any) => any {\n  return ((m: any) => (m as any).assign(fns as any)) as any;\n}\n\n/* withDefault */\nexport function withDefault<B>(defaultValue: B): {\n  <M extends Maybe<any> | AsyncMaybe<any>>(\n    m: M,\n  ): M extends Maybe<infer A>\n    ? Maybe<A | B>\n    : M extends AsyncMaybe<infer A>\n      ? AsyncMaybe<A | B>\n      : never;\n} {\n  return ((m: any) => (m as any).withDefault(defaultValue)) as any;\n}\n\n/* getOrElse */\nexport function getOrElse<A, B>(\n  defaultValue: B,\n): {\n  (m: Maybe<A>): A | B;\n  (m: AsyncMaybe<A>): Promise<A | B>;\n} {\n  return ((m: any) => (m as any).getOrElse(defaultValue)) as any;\n}\n\n/* effect */\nexport function effect<A>(fn: (value: A) => void | Promise<void>): {\n  (m: Maybe<A>): Maybe<A>;\n  (m: AsyncMaybe<A>): AsyncMaybe<A>;\n} {\n  return ((m: any) => (m as any).effect(fn as any)) as any;\n}\n"]}